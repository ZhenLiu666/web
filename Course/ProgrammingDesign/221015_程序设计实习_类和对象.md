#### 面向对象编程

- 结构化程序设计：

- - 特征：复杂问题—模块化/分解—若干子问题和自顶向下，逐步求精；

  - 结构化程序 = 数据结构（变量）+ 算法（函数）

  - - 算法就是来操作数据结构的；
    - 但是结构化程序中很难理解数据结构和算法的关系；

  - 结构化程序设计的缺点：

  - - 理解难，很难知道具体某个数据结构和函数直接是一个什么样的关系。 任何两个函数之间存在着怎么样的调用关系；
    - 修改难，结构化设计本身是没有封装概念。 想要修改某一个变量定义必须把所有访问该变量的语句全部找到；
    - 查错难，当某个数据结构的值不正常的时候，因为本身程序关系错综复杂， 很难找出到底是哪个函数所导致的；
    - 重用难，通常希望可以使用一些现有程序当中已经有的或者类似的实现。 在结构化的程序设计设计中，随着程序规模的不断增大， 由于程序关系本身错综复杂， 所以想要抽取其中需要的部分代码就会变得十分的困难；

- 面向对象的程序设计：
  - 面向对象就是设计不同的类，设计程序就是设计不同的类的过程；
  - 将一类事物的共同属性提取出来形成变量（数据结构），将事物的共同行为提取出来形成函数，组合在一起就构成了一个类；
  - **抽象和封装**是类的两个基本概念：
    - 将具象的多个事物提取出一些共同的特征就是抽象；
    - 将这些抽象出来的事物写成类使之紧密结合起来就是封装；
  - C++实现的基本过程：由具体的多个事物抽象出类的概念，再由类生成具体的类型，也就是对象化实例；



#### **从客观事物中抽象类**

- 面向对象的基本概念：

- - 介绍

  - - 类是带着一些函数封装起来的结构，与之前的抽象数据，类型只定义数据不同的
    - 将数据结构和与它相关的操作关联在一起写成类，使得数据结构和操作数据结构的算法呈现出显而易见的紧密关系；
    - 注意这些操作是专门针对此类数据结构的，换用别的数据结构就不一定适用；

  - 例子-矩形类：

  - - 矩形的属性：长和宽，需要两个变量

    - 矩形的操作：

    - - 设置矩形的长和宽；
      - 计算矩形的面积；
      - 计算矩形的周长；

    - **在定义结构体的时候，最后必须加上分号**；

- 对象的内存分配与运算符

- - 对象所占用的内存空间的大小**=** 所有成员变量的大小之和；
  - 不同的对象占用的内存空间是不同的，每个对象有自己的存储空间；
  - 对象间可以进行等号运算，CRrectangle r1,r2, r1=r2 是允许的，系统是判断的出来它们有相同的变量**,**但是不能使用==这种符号，因为这些符号没有定义相关的操作，除非进行运算符重载；

- 三种方法访问类的成员变量和成员函数

- - 对象名.成员名 CRectangle r1 ;  r1.w  
  - 指针—>成员名 CRectangle *p1 = &r1; p1—>w ;  
  - 引用名.成员名  CRectangle & rr = r1; rr.w 

- - 





#### 成员变量





#### 成员函数

- 成员函数和一般的函数定义都支持重载，即传入参数的类型和个数不同但是函数名字相同

- 成员函数支持参数缺省，只要是右侧连续的几个参数进行缺省即可

- 使用缺省参数要注意避免有函数重载时的二义性

- - void valueX( int val = 0 ) { x = val; }
  - int valueX() { return x; }
  - 上述两个成员函数在被调用的时候可能会被混淆，因为第一个也允许没有参数输入，在编程的时候要尽量避免这种情况



#### 构造函数

- 成员函数的一种

- - 名字与类名相同，可以有参数，不能有返回值(void也不行)
  - 作用是对对象进行初始化（是在已经给变量分配内存空间之后对其进行处理，而不是给变量分配内存），如给成员变量赋初值（如果定义类时没写构造函数，则编译器生成一个默认的无参数 的构造函数，默认构造函数无参数，不做任何操作）
  - 如果定义了构造函数，则编译器不生成默认的无参数的构造函数，而且是必须使用自己写的构造函数，因此当自己编写的构造函数需要参数的时候，定义也需要传进去参数，比如：Complex c1(2,3) ; Complex *p = new Complex(3,4);
  - 对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数
  - 一个类可以有多个构造函数,只要参数个数或参数类型不同，就可以使用函数重载

- 意义

- - \1) 构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数。
  - \2) 有时对象没被初始化就使用，会导致程序出错

- 构造函数在数组中的使用

- - 当我们生成对象数组的时候（数组中的每个元素都是对象），数组的长度就是构造函数的调用次数；
  - 当我们生成类型为对象的指针数组时（数组本身是指针，有没有调用构造函数需要取决于有没有指向对象，对象有没有初始化的过程）；

- 复制构造函数(copy constructor)

- - 基本概念

  - - 本质上还是构造函数，只是输入的参数不再是一般的变量，而是对象，操作可以不局限于复制操作；
    - 只有一个参数,即对同类对象的引用，而不是同类的对象，即CSsmple(Csample c)是错的；
    - 形如 X::X( X& )或X::X(const X &), 二者选一；后者能以常量对象作为参数
    - 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能

  - 其作用的三种情况

  - - 当用一个对象去初始化同类的另一个对象时。

    - - Complex c2(c1);
      - Complex c2 = c1; //初始化语句，非赋值语句
      - 上述两条语句是完全等价的，因为c2前面有Complex，但是如果是直接的c2=c1,表示c2已经生成了，这时就不会使用到复制构造函数

    - 如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类A的复制构造函数将被调用

    - - 即函数的形参被实参进行复制的时候，会调用复制构造函数
      - 注意由于我们的复制构造函数不一定是完成复制操作，因此函数的形参不一定和函数的实参是一样的！

    - 如果函数的返回值是类A的对象时，则函数返回时， A的复制构造函数被调用

    - - 即函数的类型是A的时候，生成返回值的时候用返回值return来对函数返回结果Func()进行复制；
      - 同理，由于复制函数不一定要写复制操作，因此函数返回值不一定和我们返回的结果是一致的

- 类型转换构造函数

- - 目的：实现类型的自动转换

  - 特点

  - - 只有一个参数
    - 不是复制构造函数

  - 编译系统会自动调用——转换构造函数——>有时候需要建立一个临时对象/临时变量

  - 区别

  - - Complex c1(7,8) ; // 调用构造函数
    - Complex c2 =12; //调用类型转换函数，这是在对象初始化过程中选择了不同的构造函数生成对象，不涉及生成临时对象的过程
    - c1=9; //由于这是赋值语句，c1变量已经生成了，因此不涉及到复制构造函数，这里是先用9生成了一个临时的对象实例，再把这个对象实例的值复制给c1





#### 析构函数

- 意义

- - 假设用new分配了一个动态内存，在各个地方编写语句的时候，要保证每个地方的内存都被释放是很难的；
  - 只要在析构函数中写delete语句，就能确保对象中用new分配的空间在对象消亡的时候自动被释放

- 基本介绍

- - 成员函数的一种
  - 名字与类名相同
  - 在前面加 ‘~’
  -  没有参数和返回值
  - 一个类最多只有一个析构函数
  - 对象消亡时自动被调用，在对象消亡前做善后工作，释放分配的空间等；但是对于new出来的对象，必须使用delete的时候才会调用析构函数
  - 定义类时没写析构函数, 则编译器生成缺省析构函数，**不涉及释放用户申请的内存释放等清理工作** 
  - 定义了析构函数, 则编译器不生成缺省析构函数

- 析构函数和数组

- - 对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用
  - Ctest array[2]; 在对象数组使用结束后，会调用两次析构函数；

- 析构函数和运算符

- - Ctest * pTest;
  - pTest = new Ctest; //构造函数调用
  - delete pTest; //析构函数调用 
  - pTest = new Ctest[3]; //构造函数调用3次
  - delete [] pTest; //析构函数调用3次

- 注意

- - 对象的作用域是离对象最近的一对花括号所决定的，比如d5，产生完之后就消亡了

  - 临时产生的对象，在使用类型转换构造函数之后就会消亡；

  - 被调用函数void中的static变量的存在范围是整个程序，当程序执行结束后才清空；

  - 先生成的对象后消亡，主要比较d1和d4；

    







